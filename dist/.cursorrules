# Project Overview

You are building a Laravel/Livewire application ...

## Development Principles

You always think about problems and solutions carefully, step by step and you always follow best practices for writing clean and testable code with an emphasis on readability and maintainability. You write concise, technical responses with accurate PHP/Laravel/Livewire examples.

### Before Starting Any Task

1. Check current PHP/Laravel/Livewire/Flux/Tailwind versions in `composer.json` and `package.json`
2. Formulate a detailed implementation plan using syntax and features appropriate for the installed versions
3. Review and improve the implementation plan ensuring version compatibility
4. Implement using version-specific syntax and features
5. Test

**Version Awareness**

- Always check `composer.json` and `package.json` for actual installed versions
- Use syntax and features appropriate for the specific versions found
- Never assume latest versions - adapt to what's actually installed
- Pay special attention to packages with breaking changes

**Context7**

Use Context7 for documentation about version-specific syntaxt, features and APIs.

### PHP/Laravel Standards

#### Language & Coding Standards

**Code Style & Standards**

- Follow PSR-12 coding standards
- Use strict typing: `declare(strict_types=1);`

**Modern PHP Features & Type Safety**

- Use modern PHP 8.x features including union types, match expressions, attributes, constructor property promotion, readonly classes, the nullsafe operator, etc.
- Prefer type casting over magic class methods (e.g., `(array)` instead of `__toArray()`)

**Code Quality & Structure**

- Use descriptive variable, method, class and component names
- Prefer iteration and modularization over duplication

#### Framework & Architecture

**General Architecture Principles**

- Follow PHP/Laravel best practices and conventions but avoid too many abstractions
- Use Laravel's built-in features and helpers everywhere possible
- Favor dependency injection and service containers

**Data & Business Logic**

- Use the `spatie/laravel-data` package for DTOs (Data Transfer Objects) where appropriate, including for validation
- Let application logic handle relationships between models and tables instead of hard database constraints or foreign keys
- Use Repository classes in `app/Repositories` to decouple complex query logic from the business logic
- Use Action classes in `app/Actions` to encapsulate complex operations, promote code reuse, and maintain single responsibility principle across the application

**Request Handling & Validation**

- Use Laravel's named routes for defining or redirecting to application endpoints
- Implement proper request validation using Form Requests
- Implement middleware for request filtering and modification

**Security & Authorization**

- Use Laravel's built-in authentication and authorization features
- Utilize `spatie/laravel-permission` for role-based authorization

**Frontend Implementation Standards**

- Implement all user-facing features using Laravel Livewire components
- Use the Livewire Flux UI kit for all interface components and layouts
- Style components exclusively with Tailwind CSS utility classes
- Avoid traditional Blade views with separate JavaScript files in favor of Livewire's reactive approach
- Leverage Flux components for consistent design patterns and accessibility standards

**Laravel Livewire**

- Place Livewire components in the `App\Livewire` namespace (not `App\Http\Livewire`)
- Use `$this->dispatch()` for event dispatching instead of deprecated `$this->emit` or `$this->dispatchBrowserEvent`
- Reference layouts using `components.layouts.app` path instead of `layouts.app`
- Use `wire:model.live` for real-time binding (default `wire:model` is now deferred)
- Apply the same live binding approach to `@entangle` directives
- Wrap all Livewire component content within a single root `<div>` element
- Add custom styling to `resources/css/app.css` instead of inline styles in components
- Include `wire:key` attributes on the first element within loops (`@foreach`, `@for`, etc.) for proper component tracking
- Leverage Livewire's built-in Alpine.js bundle without manually including Alpine in `resources/js/app.js`
- Use `#[On('event-name')]` attributes for event listeners instead of the `protected $listeners` property
- Implement `wire:dirty` for styling unsaved/modified component states
- Utilize `wire:loading` to provide visual feedback during component actions
- Apply `wire:confirm` for user confirmation dialogs before destructive actions
- Don't use Livewire Volt (keep component PHP logic and Blade templates separate)

#### Error Handling & User Experience

**Command Error Handling**

- Provide clear, actionable error messages
- Use Laravel's console output methods (info, warn, error)
- Implement graceful degradation for optional features
- Log errors appropriately without exposing sensitive information

**Process Management**

- Handle Symfony Process failures gracefully
- Provide progress indicators for long-running operations
- Allow users to skip failed steps and continue

#### Command Development Patterns

**Option Handling**

- Use Laravel's command option/argument methods
- Provide sensible defaults
- Validate options early in command execution

**File Operations**

- Use Laravel's File facade for file operations
- Always check if files exist before copying
- Provide backup mechanisms for overwritten files

**External Process Management**

- Use Symfony Process for shell commands
- Set appropriate timeouts
- Capture and handle both stdout and stderr

#### Performance & Security

**Process Optimization**

- Avoid unnecessary composer/npm operations
- Cache expensive operations when possible
- Use appropriate timeouts for external processes

**Security Considerations**

- Validate all user inputs and file paths
- Sanitize shell commands and arguments
- Never execute arbitrary user code
- Use Laravel's built-in security features

#### Documentation & Communication

**Code Documentation**

- Use PHPDoc blocks for all public methods
- Document complex logic with inline comments
- Keep README.md updated with usage examples

**User Communication**

- Write clear console output messages
- Provide helpful command descriptions and examples
- Use consistent terminology throughout

### Testing

**Testing Framework & Approach**

- Follow the `TESTING.md` guide closely
- Use the Pest Framework exclusively for unit and feature tests
- Always write new tests or modify existing tests for any new or updated code

**Code Quality & Standards**

- Enforce code style with Laravel Pint (configured in `pint.json`)
- Use PHPStan for static analysis (configured in `phpstan.neon`)

**Pre-commit Checks**

Run the following checks before committing anything:

**Pre-commit Workflow**
Run these commands in sequence before committing:

```bash
# 1. Fix code style issues second
php vendor/bin/pint

# 2. Check static analysis first
php vendor/bin/phpstan analyse

# 3. Verify tests still pass
php vendor/bin/pest --parallel
```

**Commit Standards**

- Use Conventional Commits format
- Write descriptive commit messages
- Keep commits atomic and focused

**Branch Strategy**

- Use feature branches for new functionality
- Ensure all tests pass before merging
- Squash commits when appropriate
